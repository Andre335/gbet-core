'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lockfile = require('lockfile');

var _lockfile2 = _interopRequireDefault(_lockfile);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _MongoBinaryDownload = require('./MongoBinaryDownload');

var _MongoBinaryDownload2 = _interopRequireDefault(_MongoBinaryDownload);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class MongoBinary {

  static getPath(opts = {}) {
    var _this = this;

    return _asyncToGenerator(function* () {
      var _opts$downloadDir = opts.downloadDir;
      const downloadDir = _opts$downloadDir === undefined ? _path2.default.resolve(_os2.default.homedir(), '.mongodb-binaries') : _opts$downloadDir;
      var _opts$platform = opts.platform;
      const platform = _opts$platform === undefined ? _os2.default.platform() : _opts$platform;
      var _opts$arch = opts.arch;
      const arch = _opts$arch === undefined ? _os2.default.arch() : _opts$arch;
      var _opts$version = opts.version;
      const version = _opts$version === undefined ? 'latest' : _opts$version;


      let debug;
      if (opts.debug) {
        if (opts.debug.call && typeof opts.debug === 'function' && opts.debug.apply) {
          debug = opts.debug;
        } else {
          debug = console.log.bind(null);
        }
      } else {
        debug = function debug(msg) {}; // eslint-disable-line
      }

      if (_this.cache[version]) {
        debug(`MongoBinary: found cached binary path for ${version}`);
      } else {
        // create downloadDir if not exists
        yield new Promise(function (resolve, reject) {
          (0, _mkdirp2.default)(downloadDir, function (err) {
            if (err) reject(err);else resolve();
          });
        });

        const lockfile = _path2.default.resolve(downloadDir, `${version}.lock`);

        // wait lock
        yield new Promise(function (resolve, reject) {
          _lockfile2.default.lock(lockfile, {
            wait: 120000,
            pollPeriod: 100,
            stale: 110000,
            retries: 3,
            retryWait: 100
          }, function (err) {
            if (err) reject(err);else resolve();
          });
        });

        // again check cache, maybe other instance resolve it
        if (!_this.cache[version]) {
          const downloader = new _MongoBinaryDownload2.default({
            downloadDir,
            platform,
            arch,
            version
          });

          downloader.debug = debug;
          _this.cache[version] = yield downloader.getMongodPath();
        }

        // remove lock
        _lockfile2.default.unlock(lockfile, function (err) {
          debug(err ? `MongoBinary: Error when removing download lock ${err}` : `MongoBinary: Download lock removed`);
        });
      }

      debug(`MongoBinary: Mongod binary path: ${_this.cache[version]}`);
      return _this.cache[version];
    })();
  }

  static hasValidBinPath(files) {
    if (files.length === 1) {
      return true;
    } else if (files.length > 1) {
      return false;
    }
    return false;
  }
}
exports.default = MongoBinary;
MongoBinary.cache = {};